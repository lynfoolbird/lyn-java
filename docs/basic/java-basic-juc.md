多线程

思维导图

https://www.processon.com/mindmap/60b8e5ae1e0853234f9eaa81

https://www.processon.com/view/59277c9de4b037d0e7843778?fromnew=1#map

原理源码 问题分析处理 性能调优 手写实现 使用demo

无锁volatile+CAS，不变类，threadlocal、synchronized、lock，不共享

1 基本概念 

进程线程区别 协程 管程 同步和异步 并行和并发 阻塞和非阻塞 临界区 上下文切换

2 计算机内存模型 原子性/可见性/指令重排有序性  JMM happens-before  unsafe类

3 JAVA多线程

创建 启动 终止 中断 阻塞 等待 死亡 可执行 执行中 状态转移 优先级  守护线程 前台现场 主线程子线程
线程组 demon sleep join(多米诺) 线程通信 线程协调 如何中断线程  线程上下文切换 cpu密集型 io密集型
Object wait notify notifyall 、

Thread  Runnable Callable yield sleep join run start 

Future  FutureTask ComplemetableFuture

4 CAS  AQS 原理源码 问题方案 CAS的三种问题及方案  

https://www.toutiao.com/i6964976741941264933/

5 volatile 原子变量Atomic 不变类 无状态类 线程安全类 ThreadLocal线程变量详解 线程私有变量 final 锁 

threadlocal

https://www.toutiao.com/i6943447031293755907/

6 深入锁机制 synchronized lock 悲观锁乐观锁 公平锁非公平锁 排它锁共享锁 可重入锁 偏向锁 自旋锁 适应性自旋锁 重量锁 轻量锁  监视器锁 锁粒度   读写分离锁  显式锁 LockSupport Condition Signal    死锁（必要条件、如何检测、死锁处理）
活锁 双检锁单例  synchronized锁升级  锁优化  锁：排他性、阻塞性、可重入性 无锁编程 有锁 StampedLock

mybatis-plus乐观锁插件 分布式锁

8 线程池 

池中线程状态 Executor 原理源码 手写实现 与ThreadLocal 调优池大小设置  CompletionService ; 连接池

https://www.toutiao.com/i6960567839778472460/

7 并发工具 

CountDownLatch(发令枪 集结号) CyclicBarrier Semphore(信号量) Phaser Exchange ForkJoin 深入源码实现 

9 并发容器 

ConcurrentHashMap ConcurrentSkipListMap CopyOnwrite 线程不安全容器  

阻塞式队列blockqueue Synchronousqueue
delayqueue  包装容器 同步容器 并发容器 1.7 1.8 实现区别

10 高并发框架 Disrupror

11 线程模型  Reactor、IO多路复用技术

12 线程安全 理解 并发安全 单例 双检锁 死锁 排查及处理 临界区 

13 面试专题

14 最佳实践


# 1 基本概念
## 1.1 进程与线程
程序：是一个静态的指令集合；进程和程序的区别在于其动态性，进程具有自己的生命周期和各种不同状态；
**进程**：一个计算机程序的运行实例，包含了需要执行的指令；有自己的独立地址空间，包含程序内容和数据；不同进程的地址空间是互相隔离的；进程拥有各种资源和状态信息，包括打开的文件、子进程和信号处理。是系统分配资源的基本单位；
**线程**：是进程的执行单元，CPU调度执行的基本单位；线程有自己的程序计数器、寄存器、堆栈和帧。同一进程中的线程共用相同的地址空间，同时共享父进程拥有的内存和其他资源。同一进程的多个线程可并发执行，线程必须有父进程而不能独立存在；
多线程优点：进程间不能共享内存而线程可以；创建线程开销更小效率更高；Java语言支持；
**协程**
**管程**

## 1.2 同步和异步
同步方法调用一旦开始，调用者必须等待方法调用返回后才能继续后面的操作；
异步方法调用一旦开始，方法调用就会立刻返回，调用者可以继续后面的操作；

## 1.3 并行和并发
**并行**：同一时间点多个任务同时执行；
**并发**：同一时间段内多个任务交替执行，具体到同一时间点则只有单个任务；
真实的并行只能出现在拥有多个CPU的系统中。
## 1.4 阻塞和非阻塞
一个线程占用了临界区资源则其他需要这个资源的线程必须在这个临界区中等待，等待会导致线程挂起，这种情况称为阻塞。
## 1.5 临界资源和临界区
**临界资源**用来表示一种公共资源或共享数据，可以被多个线程使用，但是每一次只能有一个线程使用，一旦临界区资源被占用，其他需要这个资源的线程需要等待。
**临界区**：每个进程中，访问临界资源的那段代码。

# 2 Java内存模型
 JMM as-if-serial happens-before  内存屏障

MESI协议 volatile原理  DCL unsafe类

https://www.jianshu.com/p/99b708e0aae0

https://www.jianshu.com/p/8a58d8335270

https://www.toutiao.com/i6899283404190122507/

https://zhuanlan.zhihu.com/p/133851347

## 2.1 什么是JMM
JMM就是Java内存模型(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以**java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。**

Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。

不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。
![img](images/jmm.png)

每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷回到主存。这是 Java 内存模型定义的线程基本工作方式。

温馨提醒一下，这里有些人会把Java内存模型误解为**Java内存结构**，然后答到堆，栈，GC垃圾回收，最后和面试官想问的问题相差甚远。**实际上一般问到Java内存模型都是想问多线程，Java并发相关的问题**。

## 2.2 JMM定义了什么
整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：原子性，可见性，有序性。这三个特征可谓是整个Java并发的基础。
**原子性**
原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。
举例：

```java
int i = 2;
int j = i;
i++;
i = i + 1;
```
第一句是基本类型赋值操作，必定是原子性操作。
第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。
第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。
JMM只能保证基本的原子性，如果要保证代码块的原子性，提供了monitorenter 和moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。

**可见性**
可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。除了volatile关键字之外，final和synchronized也能实现可见性。synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。

**有序性**
在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别：volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。

## 2.3 JMM内存交互规则
![img](images/jmm_内存交互操作.png)

+ lock(锁定)，作用于**主内存**中的变量，把变量标识为线程独占的状态。
+ read(读取)，作用于**主内存**的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。
+ load(加载)，作用于**工作内存**的变量，把read操作主存的变量放入到工作内存的变量副本中。
+ use(使用)，作用于**工作内存**的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
+ assign(赋值)，作用于**工作内存**的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。
+ store(存储)，作用于**工作内存**的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。
+ write(写入)：作用于**主内存**中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
+ unlock(解锁)：作用于**主内存**的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
我再补充一下JMM对**8种内存交互操作规则**吧：

+ 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。
+ 不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。
+ 不允许线程将没有assign的数据从工作内存同步到主内存。
+ 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。
+ 一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。
+ 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。
+ 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。
+ 一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。

## 2.4 Happens-before原则
https://www.toutiao.com/i6960265712749314590/

## 2.5 volatile