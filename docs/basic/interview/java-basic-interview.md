**重点掌握：**

1 面向对象思想

2 注解原理



# 1 语言基础

## 1 ⾯向对象和⾯向过程的区别
**⾯向过程** ：
⾯向过程性能⽐⾯向对象⾼。 因为类调⽤时需要实例化，开销⽐较⼤，⽐较消耗资源，所以当性能是最重要的考量因素的时候⼀般采⽤⾯向过程开发。但是， ⾯向过程没有⾯向对象易维护、易复⽤、易扩展。

**⾯向对象** ： 
⾯向对象易维护、易复⽤、易扩展。 因为⾯向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是， ⾯向对象性能⽐⾯向过程低。 

## 2 Java 语⾔有哪些特点?
1. 简单易学；
2. ⾯向对象（封装，继承，多态）；
3. 平台⽆关性（ Java 虚拟机实现平台⽆关性）；
4. 可靠性；
5. 安全性；
6. ⽀持多线程；
7. ⽀持⽹络编程并且很⽅便；
8. 编译与解释并存；

## 3 JVM、JDK和JRE？OracleJDK和OpenJDK区别？
1. Oracle JDK ⼤概每 6 个⽉发⼀次主要版本，⽽ OpenJDK 版本⼤概每三个⽉发布⼀次。
2. OpenJDK 是⼀个参考模型并且是完全开源的，⽽ Oracle JDK 是 OpenJDK 的⼀个实现，并不是完全开源的；
3. Oracle JDK ⽐ OpenJDK 更稳定。 OpenJDK 和 Oracle JDK 的代码⼏乎相同，但 OracleJDK 有更多的类和错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。
4. 在响应性和 JVM 性能⽅⾯， Oracle JDK 与 OpenJDK 相⽐提供了更好的性能；
5. Oracle JDK 不会为即将发布的版本提供⻓期⽀持，⽤户必须通过更新到最新版本获得⽀持；
6. Oracle JDK 根据⼆进制代码许可协议获得许可，⽽ OpenJDK 根据 GPL v2 许可获得许可。

## 4 Java和C++比较
都是⾯向对象的语⾔，都⽀持封装、继承和多态。

Java 不提供指针来直接访问内存，程序内存更加安全；

Java 的类是单继承的， C++ ⽀持多重继承；Java接⼝可以多继承。

Java 有⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存。

Java是平台无关可移植的。

在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符‘\0’来表示结束。但是， Java 语
⾔中没有结束符这⼀概念。

## 5 字符型常量和字符串常量的区别?
1. 形式上: 字符常量是单引号引起的⼀个字符; 字符串常量是双引号引起的若⼲个字符
2. 含义上: 字符常量相当于⼀个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表⼀个地
址值(该字符串在内存中存放位置)
3. 占内存⼤⼩ 字符常量只占 2 个字节; 字符串常量占若⼲个字节 (注意： char 在 Java 中占两
个字节)

## 6 String、StringBuffer、StringBuilder比较? String为什么是不可变的？String str = new String("123")会创建几个对象？

是否不变类；线程安全性；性能；内存占用
1. 操作少量的数据: 适⽤ String
2. 单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder
3. 多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer

不可变类遵守以下规则：

（1）类内部所有的字段都是私有的和final修饰的。

（2）类不能够被集成和拓展。

（3）类不能够对外提供哪些能够修改内部状态的方法，setter方法也不行。getter方法需要返回深拷贝克隆对象

（4）类内部的字段如果是引用，也就是说可以指向可变对象，那我们程序员不能获取这个应用。

为什么String设计成不变类？

1、字符串常量池，如果字符串可变，通过一个引用改变它的值，将会导致其他引用的值也改变，可能发生错误。

2、Java中经常用到一个字符串的hashcode，例如在HashMap和HashSet中。不可变性保证同一个字符串对象的hashcode总是相同的，而在使用时不用考虑其是否发生改变。

3、在Java中String被用作许多方法的参数，例如网络连接，对文件的操作等等。假如String不是不可变的，一个连接或文件将可能被改变，这会产生严重的安全隐患。

4、不可变对象是线程安全的，它们可以被自由地共享，不要求同步。

有什么办法能够改变String？

反射，field.setAccessible(true)，修改

String类的intern()方法为本地方法，功能是如果常量池中存在当前字符串，就会直接返回当前字符串；如果常量池中没有此字符串，会将此字符串放入常量池中后，再返回。

如果字符串常量池中有123则只创建str对象，如果没有则先在常量池中创建123再在堆中创建str对象实体。

## 7 short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 整型常量池？

对于 short s1 = 1; s1 = s1 + 1;由于 s1+1运算时会自动提升表达式的类型，所以结果是 int型，再赋值给 short 类型 s1时， 编译器将报告需要强制转换类型的错误。

对于 short s1 = 1; s1 += 1;由于 +=是 java 语言规定的运算符，编译器会对它进行特殊处理，因此可以正确编译。

## 8 静态变量与实例变量的区别？是否可从 static 方法内部发出对非 static 方法的调用？
语法上区别：静态变量加static关键字，实例变量不需要；

运行时区别：静态变量属于类由类的所有对象共享在类加载时分配空间，实例变量属于对象必须创建实例对象才会分配空间；

不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说， 当一个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个 static 方法内部发出对非 static 方法的调用。

## 9 在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤？
Java 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ super() 来调⽤⽗类特定的构造⽅法，则会调⽤⽗类中“没有参数的构造⽅法”。如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构造⽅法中⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程序在⽗类中找不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参数的构造⽅法。

## 10 final, finally, finalize 的区别

final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。内部类要访问局部变量，局部变量必须定义成 final 类型。

finally 是异常处理语句结构的一部分，表示总是执行。

finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 JVM 不保证此方法总被调用。

## 11 super.getClass()的方法调用？

getClass方法为Object类的final方法，子类不能覆写，在子类中用super.getClass方法等价于直接调用getClass方法，返回的仍是子类的Class对象；

## 12 内部类：静态内部类和普通内部类比较

（1）内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。

（2）非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。

（3）一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。

## 13 成员变量与局部变量的区别有哪些？
1. 从语法形式上看:成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；
成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰
符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
2. 从变量在内存中的存储⽅式来看:如果成员变量是使⽤ static 修饰的，那么这个成员变量是属
于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局
部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆
内存对象的引⽤或者是指向常量池中的地址。
3. 从变量在内存中的⽣存时间上看:成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局
部变量随着⽅法的调⽤⽽⾃动消失。
4. 成员变量如果没有被赋初值:则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰
的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。

## 14 创建对象有哪些方式？创建⼀个对象⽤什么运算符?对象实体与对象引⽤有何不同?
创建对象方式：new、反射、反序列化、克隆、Object

new 运算符， new 创建对象实例（对象实例在堆内存中），对象引⽤指向对象实例（对象引⽤存
放在栈内存中）。

## 15 什么是⽅法的返回值?返回值在类的⽅法⾥的作⽤是什么?
⽅法的返回值是指我们获取到的某个⽅法体中的代码执⾏后产⽣的结果。(前提是该⽅法可能产
⽣结果）。

返回值的作⽤:接收出结果，使得它可以⽤于其他的操作。

## 16 ⼀个类的构造⽅法的作⽤是什么? 若⼀个类没有声明构造⽅法，该程序能正确执⾏吗? 为什么?
主要作⽤是完成对类对象的初始化⼯作。可以执⾏。因为⼀个类即使没有声明构造⽅法也会有默
认的不带参数的构造⽅法。构造方法特性：

1. 名字与类名相同。
2. 没有返回值，但不能⽤ void 声明构造函数。
3. ⽣成类的对象时⾃动执⾏，⽆需调⽤。

## 17 静态⽅法和实例⽅法有何不同？
1. 在外部调⽤静态⽅法时，可以使⽤"类名.⽅法名"的⽅式，也可以使⽤"对象名.⽅法名"的⽅
式。⽽实例⽅法只有后⾯这种⽅式。也就是说，调⽤静态⽅法可以⽆需创建对象。
2. 静态⽅法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态⽅法），⽽不
允许访问实例成员变量和实例⽅法；实例⽅法则⽆此限制。
## 18  对象的相等与指向他们的引⽤相等,两者有什么不同?
对象的相等，⽐的是内存中存放的内容是否相等。⽽引⽤相等，⽐较的是他们指向的内存地址是否相等。

## 19 在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?
帮助⼦类做初始化⼯作。

## 20 == 与 equals(重要)
== : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型==⽐较的是值，引⽤数据类型==⽐较的是内存地址)。

equals() : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过“==”⽐较这两个对象。情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐较两个对象的内容是否相等；若它们的内容相等，则返回 true 。

## 21 hashCode 与 equals (重要)
⾯试官：你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写hashCode ⽅法？

1) hashCode()介绍:

hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode ⽅法是本地⽅法，也就是⽤ c 语⾔或 c++ 实现的，该⽅法通常⽤来将对象的 内存地址转换为整数之后返回。散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利⽤到了散列码！（可以快速找到所需要的对象）

2) 为什么要有 hashCode？

我们以“ HashSet 如何检查重复”为例⼦来说明为什么要有 hashCode？当你把对象加⼊ HashSet 时， HashSet 会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会与其他已经加⼊的对象的 hashcode 值作⽐较，如果没有相符的 hashcode， HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查 hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加⼊操作成
功。如果不同的话，就会重新散列到其他位置。这样我们就减少了 equals 的次数，相应就⼤⼤提⾼执⾏速度。

3)  为什么重写 equals 时必须重写 hashCode ⽅法？

如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等,对两个对象分别调⽤ equals⽅法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。 因此，equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖。hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）

4) 为什么两个对象有相同的 hashcode 值，它们也不⼀定是相等的？

public native int hashCode();在这⾥解释⼀位⼩伙伴的问题。以下内容摘⾃《Head Fisrt Java》。
因为 hashCode() 所使⽤的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode 。我们刚刚也提到了 HashSet ,如果 HashSet 在对⽐的时候，同样的 hashcode 有多个对象，它会使⽤ equals() 来判断是否真的相同。也就是说 hashcode 只是⽤来缩⼩查找成本。

## 22 为什么 Java 中只有值传递？
⾸先回顾⼀下在程序设计语⾔中有关将参数传递给⽅法（或函数）的⼀些专业术语。 按值调⽤(call by value)表示⽅法接收的是调⽤者提供的值，⽽按引⽤调⽤（call by reference)表示⽅法接收的是调⽤者提供的变量地址。⼀个⽅法可以修改传递引⽤所对应的变量值，⽽不能修改传递值调⽤所对应的变量值。 它⽤来描述各种程序设计语⾔（不只是 Java)中⽅法参数传递⽅式。

Java 程序设计语⾔总是采⽤按值调⽤。也就是说，⽅法得到的是所有参数值的⼀个拷⻉，也就是说，⽅法不能修改传递给它的任何参数变量的内容。 Java 中⽅法参数的使⽤情况：

⼀个⽅法不能修改⼀个基本数据类型的参数（即数值型或布尔型）。

⼀个⽅法可以改变⼀个对象参数的状态。

⼀个⽅法不能让对象参数引⽤⼀个新的对象。

## 23 深拷⻉ vs 浅拷⻉
1. 浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般的拷⻉，此为浅拷⻉。
2. 深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其内容，此为深拷⻉。

## 24 Java异常处理机制
异常是指程序运行所发生的非正常情况或错误，java使用面向对象的方式处理异常，将异常封装成对象，对象中包含异常信息；

java异常框架Throwable  Error(程序本身无法克服恢复的问题)  Exception  RuntimeException(考虑不周导致可以选择处理让程序是否继续) 受检异常(运行环境变化或异常导致，用户能够克服程序不应死掉，必须处理该类异常) 

异常举例；空指针、数组越界、类型转换失败；FileNotFoundException；try-catch-finally。try-with-resource

异常处理总结：

try 块： ⽤于捕获异常。其后可接零个或多个 catch 块，如没有 catch ，则必须跟⼀个 finally 块。
catch 块： ⽤于处理 try 捕获到的异常。
finally 块： ⽆论是否捕获或处理异常， finally 块⾥的语句都会被执⾏。当在 try 块或catch 块中遇到 return 语句时， finally 语句块将在⽅法返回之前被执⾏。

在以下 3 种特殊情况下， finally 块不会被执⾏：

1. 在 try 或 finally 块中⽤了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在异常
语句之后， finally 还是会被执⾏
2. 程序所在的线程死亡。
3. 关闭 CPU。 

**注意：** 当 try 语句和 finally 语句中都有 return 语句时，在⽅法返回之前， finally 语句的内容将被执⾏，并且 finally 语句的返回值将会覆盖原始的返回值。

## 25 assert什么时候用？

assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。

在实现中， assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确状态， assert 将给出警告或退出。

一般来说， **assertion** 用于保证程序最基本、关键的正确性。 assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常是关闭的。

## 26 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？

答：String s1 = "你好";String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");

## 27 反射获取Class对象的几种方式及区别？反射创建对象、获取设置私有属性、调用方法？

三种方式：Class.forName()，对象名.getClass()、类名.class；

区别：静态初始化、动态初始化、不初始化；

newInstance()方法、Constructor、Field、Method；

getDeclaredXXX用于获取所有，getXXX用于获取public的东东；

## 28 Java如何支持正则表达式操作的？

String类的matches、split、replaceAll等方法、Pattern类表示正则表达式对象；Matcher

//截取第一个左括号之前字符串

String str = "北京市(朝阳区)(西城区)(海淀区)";        

Pattern p = Pattern.*compile*(".*?(?=\\()");        

Matcher m = p.matcher(str);

## 29 三星：类实现的两接口有相同的方法会怎么样？

JDK很聪明，若类实现的两接口有同名方法则不报错，实现类只覆写一个，两父接口均可用；

## 30 重载与重写的区别？构造器能否重写？为何重载不能通过返回值区分？
方法的重载和重写都是实现多态的方式，

区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）；

重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，访问修饰符大于等于父类，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求；

构造器不能被继承所以不能重写；

方法调用有时不关注返回值而且对于返回兼容类型的方法无法区分调用哪个。

哪几类方法不能被重写？私有、final、static、构造器

## 31 接口和抽象类比较？接口是否可继承接口?抽象类是否可实现接口?抽象类是否可继承具体类?抽象类中是否可以有静态的 main 方法？

0 变量：抽象类可以私有变量，而接口中变量为public static final的

1 抽象类中可以可有非抽象方法(实现)，接口方法都是抽象的public abstract

2 抽象类可以有构造器，接口没有构造器

3 抽象类可以实现接口，而接口不能继承抽象类，接口只能extends接口；

4 类只能继承一个抽象类，但可以实现多个接口

什么时候使用抽象类和接口？

合成复用原则，接口优先，如果你拥有一些方法并且想让它们中的一些有默认实现；如果你想实现多重继承，那么你必须使用接口；如果基本功能在不断改变，那么就需要使用抽象类

Java8中的默认方法和静态方法，Java 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。

接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的 main 方法。

只有记住抽象类与普通类的唯一区别： 就是不能创建实例对象和允许有 abstract 方法。

## 32 Object中有哪些公共方法？
equals()

clone()

getClass()

wait()、notify()、notifyAll()

toString()

## 33 switch 是否能作用在byte 上，是否能作用在long,float 上，是否能作用在String上？
在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。

从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，

从Java 7开始，expr还可以是字符串（String），但是长整型（long）,浮点数（float）在目前的版本中都不支持。

## 34 注解原理 

# 2 JAVA集合

[集合面试](./collection-interview.md)

# 3 IO流

## 1 Java中有几种流？IO框架图？字符流和字节流区别？

字符编码

## 2 说说什么是序列化？如何实现序列化？ Java 序列化中如果有些字段不想进⾏序列化，怎么办？

对于不想进⾏序列化的变量，使⽤ transient 关键字修饰。

transient 关键字的作⽤是：阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。

 transient 只能修饰变量，不能修饰类和⽅法。 

## 3 说说Java NIO与IO的区别？

缓冲、非阻塞
