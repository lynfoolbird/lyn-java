数据库事务 定义 ACID 提交 回滚 不同db区别

JDBC事务   ORM支持  redis事务 JTA JPA等

隔离级别 脏读 幻读 不可重复读 第一类丢失 第二类丢失
传播行为  同一类中，不同类中 不同应用件 不同库

spring事务 编程式 声明式  事务失效场景 AOP @Transaction

why分布式事务 

 TCC 2PC 3PC  XA SAGAS模式 Atomiks  LCN Seata

RocketMQ事务消息  最大努力通知 本地消息表
对比 选型

异步线程与事务区别

https://www.cnblogs.com/dyzcs/p/13780668.html

https://zhuanlan.zhihu.com/p/183753774

微信收藏

https://mp.weixin.qq.com/s/_VdDBBsnej4uombcZtcs2A

https://mp.weixin.qq.com/s/Y9d_xyU9xw05QsHz9cYkVQ

https://mp.weixin.qq.com/s/CO9SBEyhh62rwpRqKCi9Tw



# 1. 基础概念

## 1.1 什么是事务
事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。

## 1.2 数据库事务
在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。

数据库事务的四大特性：ACID
**A（Atomic）**：原子性，构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。
**C（Consistency）**：一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转 100 元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出 100 元，李四账户没有增加 100 元这就出现了数 据错误，就没有达到一致性。
**I（Isolation）**：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务的运行过程的中间状态。通过配置事务隔离级别可以比避免脏读、重复读问题。
**D（Durability）**：持久性，事务完成之后，该事务对数据的更改会持久到数据库，且不会被回滚。

数据库事务在实现时会将一次事务的所有操作全部纳入到一个不可分割的执行单元，该执行单元的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚。

## 1.3 隔离级别

## 1.4 传播行为

# 2 Spring事务

# 3 分布式事务

https://www.toutiao.com/a6934602543481963016/?channel=&source=search_tab

https://www.toutiao.com/a6872523766392422926/?channel=&source=search_tab

分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为**分布式事务**，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。

我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：
```
begin transaction；    //1.本地数据库操作：张三减少金额    //2.本地数据库操作：李四增加金额commit transation;
```
但是在分布式环境下，会变成下边这样：
```
begin transaction；    //1.本地数据库操作：张三减少金额    //2.远程调用：让李四增加金额commit transation;
```
可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。

因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。

## 1.4 产生场景
1. **跨JVM进程产生分布式事务**
   典型的场景就是微服务架构：微服务之间通过远程调用完成事务操作。比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减少库存。订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。
2. **跨数据库实例产生分布式事务**
   单体系统访问多个数据库实例当单体系统需要访问多个数据库（实例）时就会产生分布式事务。比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。

## 2 解决方案

### 2.1 两阶段提交(2PC)

即XA方案，熟悉mysql的同学对两阶段提交应该颇为熟悉，mysql的事务就是通过**日志系统**来完成两阶段提交的。两阶段协议可以用于单机集中式系统，由事务管理器协调多个资源管理器；也可以用于分布式系统，**由一个全局的事务管理器协调各个子系统的局部事务管理器完成两阶段提交**。
这个协议有两个角色，A节点是事务的协调者，B和C是事务的参与者。
事务的提交分成两个阶段
第一个阶段是**投票阶段**
1.协调者首先将命令写入日志
2 发一个prepare命令给B和C节点这两个参与者
3.B和C收到消息后，根据自己的实际情况，判断自己的实际情况是否可以提交
4.将处理结果记录到日志系统
5.将结果返回给协调者
![img](images/distribute-transaction-2pc-1.png)

第二个阶段是**决定阶段**
当A节点收到B和C参与者所有的确认消息后
判断所有协调者是否都可以提交如果可以则写入日志并且发起commit命令有一个不可以则写入日志并且发起abort命令
参与者收到协调者发起的命令，执行命令
将执行命令及结果写入日志
返回结果给协调者
![img](images/distribute-transaction-2pc-2.png)

**可能会存在哪些问题？**
- 单点故障：一旦事务管理器出现故障，整个系统不可用
- 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
- 响应时间较长：整个消息链路是串行的，要等待响应结果，不适合高并发的场景
- 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。

### 2.2 三阶段提交(3PC)

三阶段提交又称3PC，相对于2PC来说增加了CanCommit阶段和超时机制。 如果段时间内没有收到协调者的commit请求，那么就会自动进行commit，解决了2PC单点故障的问题。
但是性能问题和不一致问题仍然没有根本解决。下面我们还是一起看下三阶段流程的是什么样的？
- 第一阶段：**CanCommit阶段** 这个阶段所做的事很简单，就是协调者询问事务参与者，你是否有能力完成此次事务。如果都返回yes，则进入第二阶段，有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求
- 第二阶段：**PreCommit阶段** 此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作，并将Undo和Redo信息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。
- 第三阶段：**DoCommit阶段** 在阶段二中如果所有的参与者节点都可以进行PreCommit提交，那么协调者就会从“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送"doCommit"请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。 相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。

### 2.3 补偿事务TCC

TCC其实就是采用的补偿机制，其核心思想是：**针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作**。它分为三个阶段：

**Try,Confirm,Cancel**

- Try阶段主要是对**业务系统做检测及资源预留**，其主要分为两个阶段Confirm 阶段主要是对**业务系统做确认提交**，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，**预留资源释放**。

比如下一个订单减一个库存：
![img](images/distribute-transaction-tcc-demo.png)

执行流程：

- Try阶段：订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于1，然后将可用库存数量设置为库存剩余数量-1，如果Try阶段**执行成功**，执行Confirm阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量如果Try阶段**执行失败**，执行Cancel阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量

TCC 事务机制相比于上面介绍的2PC，解决了其几个缺点：

- 1.**解决了协调者单点**，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
- 2.**同步阻塞**：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
- 3.**数据一致性**，有了补偿机制之后，由业务活动管理器控制一致性

总之，TCC 就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，并且很大程度的**增加**了业务代码的**复杂度**，因此，这种模式并不能很好地被复用。

### 2.4 本地消息表

![img](images/distribute-transaction-local-message.png)

执行流程：

- 消息生产方，需要额外建一个消息表，并**记录消息发送状态**。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
- 消息消费方，需要**处理**这个**消息**，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了如果处理失败，那么就会重试执行。如果是**业务上面的失败**，可以给生产方**发送一个业务补偿消息**，通知生产方进行回滚等操作。
- 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。

### 2.5 消息事务
消息事务的原理是将两个事务**通过消息中间件进行异步解耦**，和上述的本地消息表有点类似，但是是通过消息中间件的机制去做的，其本质就是'将本地消息表封装到了消息中间件中'。

执行流程：

- 发送prepare消息到消息中间件
- 发送成功后，执行本地事务如果事务执行成功，则commit，消息中间件将消息下发至消费端如果事务执行失败，则回滚，消息中间件将这条prepare消息删除
- 消费端接收到消息进行消费，如果消费失败，则不断重试

这种方案也是实现了**最终一致性**，对比本地消息表实现方案，不需要再建消息表，**不再依赖本地数据库事务**了，所以这种方案更适用于高并发的场景。目前市面上实现该方案的**只有阿里的 RocketMQ**。

### 2.6 最大努力通知

最大努力通知的方案实现比较简单，适用于一些最终一致性要求较低的业务。

执行流程：

- 系统 A 本地事务执行完之后，发送个消息到 MQ；

- 这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；

- 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。

适用场景：

### 2.7 SAGA事务模型

Saga事务模型又叫做长时间运行的事务，其核心思想是**将长事务拆分为多个本地短事务**，由Saga事务协调器协调，如果正常结束那就正常完成，如果**某个步骤失败，则根据相反顺序一次调用补偿操作**。

Seata框架中一个分布式事务包含3中角色：

**Transaction Coordinator (TC)**： 事务协调器，维护全局事务运行状态，负责协调并驱动全局事务提交或回滚。 **Transaction Manager (TM)**： 控制全局事务边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。 

**Resource Manager (RM)**： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。

seata框架**为每一个RM维护了一张UNDO_LOG表**，其中保存了每一次本地事务的回滚数据。

具体流程： 

1.首先TM 向 TC 申请**开启一个全局事务**，全局事务**创建**成功并生成一个**全局唯一的 XID**。

2.XID 在微服务调用链路的上下文中传播。

3.RM 开始执行这个分支事务，RM首先解析这条SQL语句，**生成对应的UNDO_LOG记录**。下面是一条UNDO_LOG中的记录，UNDO_LOG表中记录了分支ID，全局事务ID，以及事务执行的redo和undo数据以供二阶段恢复。

4.RM在同一个本地事务中**执行业务SQL和UNDO_LOG数据的插入**。在提交这个本地事务前，RM会向TC**申请关于这条记录的全局锁**。如果申请不到，则说明有其他事务也在对这条记录进行操作，因此它会在一段时间内重试，重试失败则回滚本地事务，并向TC汇报本地事务执行失败。

5.RM在事务提交前，**申请到了相关记录的全局锁**，然后直接提交本地事务，并向TC**汇报本地事务执行成功**。此时全局锁并没有释放，全局锁的释放取决于二阶段是提交命令还是回滚命令。

6.TC根据所有的分支事务执行结果，向RM**下发提交或回滚**命令。

- RM如果**收到TC的提交命令**，首先**立即释放**相关记录的全局**锁**，然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。
- RM如果**收到TC的回滚命令**，则会开启一个本地事务，通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。将 UNDO LOG 中的后镜与当前数据进行比较，如果不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。如果相同，根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句并执行，然后提交本地事务达到回滚的目的，最后释放相关记录的全局锁。

总结
可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。

## 分布式事务框架
TX-LCN
SEATA



