## 问题说明：

给定一个整数数组numbers，从数组中找出两个数满足相加之和等于目标数target，假设每个输入只对应唯一的答案，而且不可以重复使用相同的元素，返回两数的下标，以数组形式返回。

场景一：数组是无序数组

## 解法一：穷举法
```java
// 穷举法，时间复杂度O(n^2)，空间复杂度O(1)
public static int[] twoSum1(int[] numbers, int target) {
        for (int i=0; i<numbers.length; i++) {
            for (int j=i+1; j<numbers.length; j++) {
                if (numbers[i]+numbers[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[0];
    }
```
## 解法二：以空间换时间
```java
// 以空间换时间，时间复杂度O(n),空间复杂度O(n)
    public static int[] twoSum2(int[] numbers, int target) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i=0; i<numbers.length; i++) {
            if (map.containsKey(target-numbers[i])) {
                return new int[]{map.get(target-numbers[i]), i};
            }
            map.put(numbers[i], i);
        }
        return new int[0];
    }

```

场景二：数组是有序数组

## 解法三：二分查找
```java
// 二分查找法
    public static int[] twoSum3binarySearch(int[] numbers, int target) {
        for (int i=0; i<numbers.length; i++) {
            int low = i;
            int high = numbers.length - 1;
            while (low <= high) {
                int mid = (high - low) / 2 + low;
                if (numbers[mid]==target-numbers[i] ) {
                    return new int[]{i, mid};
                } else if (numbers[mid]>target-numbers[i]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
        }

        return new int[0];
    }
```

## 解法四：双指针思想
```java
// 双指针思路，时间复杂度O(1)，空间复杂度O(1)  最优解
    public static int[] twoSum4twoPointer(int[] numbers, int target) {
        int low = 0;
        int high = numbers.length - 1;
        while (low < high) {
            int sum = numbers[low] + numbers[high];
            if (sum == target) {
                return new int[]{low, high};
            } else if (sum<target) {
                low++;
            } else {
                high--;
            }
        }
        return new int[0];
    }
```
